#pragma warning disable IDE0058

namespace AZ.Generator.EntityFrameworkCore.Generators;

[Generator]
public sealed class EntitySetsGenerator : IIncrementalGenerator
{
	private readonly StringBuilder sb = new();

	#region Init

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(AddAttributes);

		var syntaxProvider = context.SyntaxProvider
			.ForAttributeWithMetadataName($"{Namespaces.Attributes}.{Attributes.EntitySets}", Filter, Transform)
			.Select((tuple, ct) =>
			{
				var parser = new EntitySetsParser();
				var spec = parser.Parse(tuple.Node, tuple.SemanticModel, ct);
				var diagnostics = parser.Diagnostics.ToImmutableEquatableArray();
				return (spec, diagnostics);
			})
			.WithTrackingName(TrackingNames.EntitySets);

		context.RegisterSourceOutput(syntaxProvider, ReportDiagnosticsAndEmit);
	}

	private static bool Filter(SyntaxNode node, CancellationToken _) => node is ClassDeclarationSyntax;
	private static (TypeDeclarationSyntax Node, SemanticModel SemanticModel) Transform(GeneratorAttributeSyntaxContext context, CancellationToken _) =>
		((TypeDeclarationSyntax)context.TargetNode, context.SemanticModel);

	#endregion

	#region Post-init

	private void AddAttributes(IncrementalGeneratorPostInitializationContext context)
	{
		context.AddEmbeddedAttributeDefinition();

		var entitySetsText = SourceText.From(Attributes.EntitySetsDefinition, Encoding.UTF8);
		var entitySetConfigText = SourceText.From(Attributes.EntitySetConfigDefinition, Encoding.UTF8);

		context.AddSource($"{Attributes.EntitySets}.g.cs", entitySetsText);
		context.AddSource($"{Attributes.EntitySetConfig}.g.cs", entitySetConfigText);
	}

	#endregion

	#region Generate

	private void ReportDiagnosticsAndEmit(SourceProductionContext context, (EntitySetsSpec? Spec, ImmutableEquatableArray<Diagnostic> Diagnostics) input)
	{
		var spec = input.Spec;
		var diagnostics = input.Diagnostics;

		foreach (var diagnostic in diagnostics)
		{
			context.ReportDiagnostic(diagnostic);
		}

		if (spec is null)
		{
			return;
		}

		context.CancellationToken.ThrowIfCancellationRequested();

		GenerateEntitySets(in context, spec);
	}

	private void GenerateEntitySets(in SourceProductionContext context, EntitySetsSpec spec)
	{
		sb.Clear();

		var dbContextSpec = spec.DbContextSpec;

		var classDeclaration =
			$$"""
			// <auto-generated />
			#nullable enable

			namespace {{dbContextSpec.Namespace}};

			partial class {{dbContextSpec.Name}}
			{
			""";
		sb.AppendLine(classDeclaration);

		foreach (var entity in spec.Entities)
		{
			var dbSet =
				$$"""
					{{entity.Accessibility.ToKeyword()}} Microsoft.EntityFrameworkCore.DbSet<{{entity.FullyQualifiedName}}> {{entity.DbSetName}} { get; private set; }
				""";
			sb.AppendLine(dbSet);
		}

		var classClosure =
			"""
			}

			""";
		sb.AppendLine(classClosure);

		var hint = $"EntitySets-{dbContextSpec.Name}-{spec.EntitiesNamespace}.g.cs";
		var sourceText = SourceText.From(sb.ToString(), Encoding.UTF8);

		context.AddSource(hint, sourceText);
	}

	#endregion
}
