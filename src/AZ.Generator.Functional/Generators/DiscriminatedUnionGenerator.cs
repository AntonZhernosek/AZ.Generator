#pragma warning disable IDE0058

namespace AZ.Generator.Functional.Generators;

[Generator]
public sealed class DiscriminatedUnionGenerator : IIncrementalGenerator
{
	private readonly StringBuilder sb = new();

	#region Init

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(AddAttributes);

		var syntaxProvider = context.SyntaxProvider
			.ForAttributeWithMetadataName($"{Namespaces.Attributes}.{Attributes.DiscriminatedUnion}", Filter, Transform)
			.Select((tuple, ct) => Parser.Parse(tuple.Node, tuple.SemanticModel, ct))
			.WithTrackingName(TrackingNames.DiscriminatedUnion);

		context.RegisterSourceOutput(syntaxProvider, Generate);
	}

	private static bool Filter(SyntaxNode node, CancellationToken _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax;
	private static (TypeDeclarationSyntax Node, SemanticModel SemanticModel) Transform(GeneratorAttributeSyntaxContext context, CancellationToken _) =>
		((TypeDeclarationSyntax)context.TargetNode, context.SemanticModel);

	#endregion

	#region Post-init

	private void AddAttributes(IncrementalGeneratorPostInitializationContext context)
	{
		context.AddEmbeddedAttributeDefinition();

		var discriminatedUnionAttributeText = SourceText.From(Attributes.DiscriminatedUnionDefinition, Encoding.UTF8);
		var discriminatedUnionMemberAttributeText = SourceText.From(Attributes.DiscriminatedUnionMemberDefinition, Encoding.UTF8);

		context.AddSource($"{Attributes.DiscriminatedUnion}.g.cs", discriminatedUnionAttributeText);
		context.AddSource($"{Attributes.DiscriminatedUnionMember}.g.cs", discriminatedUnionMemberAttributeText);
	}

	#endregion

	#region Generate

	private void Generate(SourceProductionContext context, DiscriminatedUnionSpec? spec)
	{
		if (spec is null)
		{
			return;
		}

		context.CancellationToken.ThrowIfCancellationRequested();

		if (spec.Accessibility.IsPublicAccessibility())
		{
			GenerateExtensionMethodClass(in context, spec);
			return;
		}

		GeneratePartialImplementation(in context, spec);
	}

	#region Extensions

	private void GenerateExtensionMethodClass(in SourceProductionContext context, DiscriminatedUnionSpec spec)
	{
		if (spec.Implementations.Count == 0)
		{
			return;
		}

		sb.Clear();

		var className = $"{spec.NameWithContainingTypes}Extensions";
		var accessibility = spec.Accessibility is Accessibility.Internal ? "internal" : "public";

		var classDeclaration =
			$$"""
			// <auto-generated />
			#nullable enable
			
			// We cover all possible cases with switch
			#pragma warning disable CS8509

			namespace {{Namespaces.Extensions}};

			{{accessibility}} static class {{className}}
			{
			""";
		sb.AppendLine(classDeclaration);

		// Methods
		var options = GenerationOptions.GenerateStatic;

		GenerateMatchMethod(spec, in options);
		GenerateSwitchMethod(spec, in options);
		GenerateIsMethods(spec, in options);
		
		// Remove empty line after last method
		sb.TrimEnd();

		// Close
		var classClosure =
			$$"""

            }
            """;
		sb.AppendLine(classClosure);

		var hint = $"{className}.g.cs";
		var sourceText = SourceText.From(sb.ToString(), Encoding.UTF8);

		context.AddSource(hint, sourceText);
	}

	#endregion

	#region Partial

	private void GeneratePartialImplementation(in SourceProductionContext context, DiscriminatedUnionSpec spec)
	{
		var implementations = spec.Implementations;

		if (implementations.Count == 0)
		{
			return;
		}

		sb.Clear();

		var containingTypes = spec.ContainingTypes;
		var containingTypeNamespace = containingTypes.First().Namespace;
		var nestedDeclaration = GetNestedDeclaration(spec, containingTypes);

		var @namespace = string.IsNullOrWhiteSpace(containingTypeNamespace) ? "" : $"namespace {containingTypeNamespace};";

		var classDeclaration =
			$$"""
			// <auto-generated />
			#nullable enable
			
			// We cover all possible cases with switch
			#pragma warning disable CS8509

			{{@namespace}}

			{{nestedDeclaration}}

			""";

		var hint = $"{spec.NameWithContainingTypes}.g.cs";
		var sourceText = SourceText.From(classDeclaration, Encoding.UTF8);

		context.AddSource(hint, sourceText);
	}

	private string GetNestedDeclaration(DiscriminatedUnionSpec spec, IEnumerable<ContainingTypeSpec> containingTypes)
	{
		if (!containingTypes.Any())
		{
			return GetPartialUnionImplementation(spec);
		}

		var partialDeclaration = containingTypes.First().GetPartialDeclaration();
		var nestedContainingTypes = containingTypes.Skip(1);

		var nestedDeclarations = GetNestedDeclaration(spec, nestedContainingTypes);

		var declaration =
			$$"""
			{{partialDeclaration}}
			{
				{{nestedDeclarations.ApplyNewlineTab()}}
			}
			""";

		return declaration;
	}

	private string GetPartialUnionImplementation(DiscriminatedUnionSpec spec)
	{
		var partialDeclaration = spec.GetPartialDeclaration();

		// Methods
		var options = GenerationOptions.GenerateInstance;

		GenerateMatchMethod(spec, in options);
		GenerateSwitchMethod(spec, in options);
		GenerateIsMethods(spec, in options);

		var classDeclaration =
			$$"""
			{{partialDeclaration}}
			{
			{{sb.TrimEnd()}}
			}
			""";

		return classDeclaration;
	}

	#endregion

	#region Method generation

	private void GenerateMatchMethod(DiscriminatedUnionSpec spec, in GenerationOptions options)
	{
		var implementations = spec.Implementations;

		var genericParameterName = GetGenericParameterName();
		var matchDeclaration = GetMethodDeclaration(in options);
		sb.AppendLine(matchDeclaration);

		var matchArgumentList = implementations.Select(t =>
		{
			var typeName = t.FullyQualifiedName;
			var argumentName = t.ArgumentName;

			var result =
				$$"""        
                        System.Func<{{typeName}}, {{genericParameterName}}> {{argumentName}}
                """;

			return result;
		});
		var matchArguments = $"{matchArgumentList.Join(",\r\n")})";
		sb.AppendLine(matchArguments);

		var returnDeclaration = GetReturnDeclaration(in options);
		sb.AppendLine(returnDeclaration);

		var switchMappings = implementations.Select(t =>
		{
			var typeName = t.FullyQualifiedName;
			var funcName = t.ArgumentName;
			var variableName = t.LocalVariableName;

			var result =
			$$"""
                        {{typeName}} {{variableName}} => {{funcName}}({{variableName}}),
            """;

			return result;
		});
		var switchMappingsString = switchMappings.Join("\r\n");
		sb.AppendLine(switchMappingsString);

		var matchMethodClosure =
			$$"""
                    };
                }

            """;
		sb.AppendLine(matchMethodClosure);

		string GetGenericParameterName()
		{
			var name = "TResult";
			
			var genericParameters = spec.ContainingTypes.SelectMany(x => x.TypeParameters)
				.Concat(spec.TypeParameters)
				.ToList();

			if (genericParameters.Count == 0)
			{
				return name;
			}

			var tiebreakName = $"{name}";
			var index = 1;

			while (genericParameters.Any(param => param.Name == tiebreakName))
			{
				tiebreakName = $"{name}{index++}";
			}

			return tiebreakName;
		}

#pragma warning disable CS8524
		string GetMethodDeclaration(in GenerationOptions options) => options switch
		{
			GenerationOptions.GenerateStatic =>
				$$"""
					public static {{genericParameterName}} Match<{{genericParameterName}}>([System.Diagnostics.CodeAnalysis.DisallowNull] this {{spec.FullyQualifiedName}} value,
				""",

			GenerationOptions.GenerateInstance => 
				$$"""
					public {{genericParameterName}} Match<{{genericParameterName}}>(
				""",
		};

		static string GetReturnDeclaration(in GenerationOptions options) => options switch
		{
			GenerationOptions.GenerateStatic =>
				$$"""
					{
						return value switch 
						{    
				""",

			GenerationOptions.GenerateInstance =>
				$$"""
				    {
				        return this switch 
				        {    
				""",
		};
#pragma warning restore CS8524
	}

	private void GenerateSwitchMethod(DiscriminatedUnionSpec spec, in GenerationOptions options)
	{
		var implementations = spec.Implementations;

		var methodDeclaration = GetMethodDeclaration(in options);
		sb.AppendLine(methodDeclaration);

		var methodArguments = implementations.Select(t =>
		{
			var typeName = t.FullyQualifiedName;
			var argumentName = t.ArgumentName;

			var result =
				$$"""
                        System.Action<{{typeName}}> {{argumentName}}
                """;

			return result;
		});
		var methodArgumentsString = $"{methodArguments.Join(",\r\n")})";
		sb.AppendLine(methodArgumentsString);

		var switchBlockDeclaration = GetSwitchBlockDeclaration(in options);
		sb.AppendLine(switchBlockDeclaration);

		var switchOptions = implementations.Select(t =>
		{
			var typeName = t.FullyQualifiedName;
			var funcName = t.ArgumentName;
			var variableName = t.LocalVariableName;

			var result =
				$$"""
                            case {{typeName}} {{variableName}}:
                                {{funcName}}({{variableName}});
                                break;
                """;

			return result;
		});

		var emptySpace =
			$$"""



            """;
		var switchOptionsString = switchOptions.Join(emptySpace);
		sb.AppendLine(switchOptionsString);

		var methodClosure =
			"""
                    }
                }

            """;
		sb.AppendLine(methodClosure);

#pragma warning disable CS8524
		string GetMethodDeclaration(in GenerationOptions options) => options switch
		{
			GenerationOptions.GenerateStatic =>
				$$"""
				    public static void Switch([System.Diagnostics.CodeAnalysis.DisallowNull] this {{spec.FullyQualifiedName}} value,
				""",

			GenerationOptions.GenerateInstance =>
				$$"""
					public void Switch(
				""",
		};

		static string GetSwitchBlockDeclaration(in GenerationOptions options) => options switch
		{
			GenerationOptions.GenerateStatic =>
				$$"""
				    {
				        switch (value)
				        {
				""",

			GenerationOptions.GenerateInstance =>
				$$"""
				    {
				        switch (this)
				        {
				""",
		};
#pragma warning restore CS8524
	}

	private void GenerateIsMethods(DiscriminatedUnionSpec spec, in GenerationOptions options)
	{
		var implementations = spec.Implementations;

		foreach (var implementation in implementations)
		{
			var implementationFullyQualified = implementation.FullyQualifiedName;

			var methodDeclaration = GetMethodDeclaration(implementation, in options);
			var castParameterName = GetCastParameterName(in options);

			var method =
				$$"""
					{{methodDeclaration}}
						[System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out {{implementationFullyQualified}} implementation)
					{
						implementation = ({{implementationFullyQualified}}){{castParameterName}};
						return implementation is not null;
					}

				""";

			sb.AppendLine(method);
		}

#pragma warning disable CS8524
		string GetMethodDeclaration(UnionImplementationSpec implementation, in GenerationOptions options)
		{
			var methodName = implementation.IsMethodName;
			return options switch
			{
				GenerationOptions.GenerateStatic =>
					$$"""
					public static bool {{methodName}}([System.Diagnostics.CodeAnalysis.DisallowNull] this {{spec.FullyQualifiedName}} value, 
					""",

				GenerationOptions.GenerateInstance =>
					$$"""
					public bool {{methodName}}(
					""",
			};
		}

		static string GetCastParameterName(in GenerationOptions options) => options switch
		{
			GenerationOptions.GenerateStatic => "value",
			GenerationOptions.GenerateInstance => "this",
		};
#pragma warning restore CS8524
	}

	#endregion

	#endregion

	#region Classes

	private enum GenerationOptions
	{
		GenerateStatic,
		GenerateInstance,
	}

	#endregion
}
