//HintName: ContainingTypeNestedContainingTypeNestedUnion.g.cs
// <auto-generated />
#nullable enable

// We cover all possible cases with switch
#pragma warning disable CS8509

namespace Foo.Bar.Baz;

partial class ContainingType
{
	partial class NestedContainingType<TResult>
		where TResult : global::System.IDisposable, new()
	{
		partial class NestedUnion
		{
			public TResult1 Match<TResult1>(
		        System.Func<global::Foo.Bar.Baz.ContainingType.NestedContainingType<TResult>.NestedImplementation, TResult1> onNestedImplementation)
		    {
		        return this switch 
		        {    
		            global::Foo.Bar.Baz.ContainingType.NestedContainingType<TResult>.NestedImplementation __NestedImplementation => onNestedImplementation(__NestedImplementation),
		        };
		    }
		
			public void Switch(
		        System.Action<global::Foo.Bar.Baz.ContainingType.NestedContainingType<TResult>.NestedImplementation> onNestedImplementation)
		    {
		        switch (this)
		        {
		            case global::Foo.Bar.Baz.ContainingType.NestedContainingType<TResult>.NestedImplementation __NestedImplementation:
		                onNestedImplementation(__NestedImplementation);
		                break;
		        }
		    }
		
			public bool IsNestedImplementation(
				[System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Foo.Bar.Baz.ContainingType.NestedContainingType<TResult>.NestedImplementation implementation)
			{
				implementation = (global::Foo.Bar.Baz.ContainingType.NestedContainingType<TResult>.NestedImplementation)this;
				return implementation is not null;
			}
		}
	}
}
