//HintName: ContainingTypeNestedUnionExtensions.g.cs
// <auto-generated />
#nullable enable

// We cover all possible cases with switch
#pragma warning disable CS8509

namespace AZ.Generator.Functional.Extensions;

public static class ContainingTypeNestedUnionExtensions
{
	public static TResult Match<TResult>([System.Diagnostics.CodeAnalysis.DisallowNull] this global::Foo.Bar.Baz.ContainingType.NestedUnion value,
        System.Func<global::Foo.Bar.Baz.ContainingType.NestedImplementation, TResult> onNestedImplementation)
	{
		return value switch 
		{    
            global::Foo.Bar.Baz.ContainingType.NestedImplementation __NestedImplementation => onNestedImplementation(__NestedImplementation),
        };
    }

    public static void Switch([System.Diagnostics.CodeAnalysis.DisallowNull] this global::Foo.Bar.Baz.ContainingType.NestedUnion value,
        System.Action<global::Foo.Bar.Baz.ContainingType.NestedImplementation> onNestedImplementation)
    {
        switch (value)
        {
            case global::Foo.Bar.Baz.ContainingType.NestedImplementation __NestedImplementation:
                onNestedImplementation(__NestedImplementation);
                break;
        }
    }

	public static bool IsNestedImplementation([System.Diagnostics.CodeAnalysis.DisallowNull] this global::Foo.Bar.Baz.ContainingType.NestedUnion value, 
		[System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Foo.Bar.Baz.ContainingType.NestedImplementation implementation)
	{
		implementation = (global::Foo.Bar.Baz.ContainingType.NestedImplementation)value;
		return implementation is not null;
	}
}
